import React, { createContext, useState, useEffect, useContext } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { PortfolioItem, Instrument, CashItem } from '../types';
import { MarketDataService } from '../services/marketData';

// Define RealizedTrade type
interface RealizedTrade {
    id: string;
    instrumentId: string;
    amount: number;
    sellPrice: number;
    buyPrice: number; // This is the averageCost at the time of sale
    currency: 'USD' | 'TRY'; // Currency of the original item
    date: number; // Timestamp of the sale
    profit: number; // Profit in the item's original currency
    profitUsd: number;
    profitTry: number;
}



interface HistoryPoint {
    date: string; // YYYY-MM-DD
    valueTry: number;
    valueUsd: number;
}

interface PortfolioContextType {
    portfolio: PortfolioItem[];
    realizedTrades: RealizedTrade[];
    history: HistoryPoint[];
    addToPortfolio: (instrument: Instrument, amount: number, cost: number, currency: 'USD' | 'TRY', date: number, historicalUsdRate?: number, besData?: { principal: number, stateContrib: number, stateContribYield: number, principalYield: number }) => Promise<void>;
    addAsset: (asset: Omit<PortfolioItem, 'id'>) => Promise<void>;
    updateAsset: (id: string, newAmount: number, newAverageCost: number) => Promise<void>;
    sellAsset: (id: string, amount: number, sellPrice: number, date: string) => Promise<void>;
    deleteAsset: (id: string) => Promise<void>;
    removeFromPortfolio: (id: string) => Promise<void>;
    refreshPrices: () => Promise<void>;
    totalValueTry: number;
    totalValueUsd: number;
    totalRealizedProfitTry: number;
    totalRealizedProfitUsd: number;
    isLoading: boolean;
    cashBalance: number; // Total cash balance (calculated from cashItems)
    cashItems: CashItem[]; // Individual cash items
    addCashItem: (item: Omit<CashItem, 'id'>) => Promise<void>;
    updateCashItem: (id: string, amount: number) => Promise<void>;
    deleteCashItem: (id: string) => Promise<void>;
    updateCash: (amount: number) => Promise<void>; // Legacy - adds to default cash
    updateTotalValue: (valTry: number, valUsd: number) => void;
    resetData: () => Promise<void>;
    clearHistory: () => Promise<void>;
}

const PortfolioContext = createContext<PortfolioContextType | undefined>(undefined);

export const PortfolioProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const [portfolio, setPortfolio] = useState<PortfolioItem[]>([]);
    const [realizedTrades, setRealizedTrades] = useState<RealizedTrade[]>([]);
    const [history, setHistory] = useState<HistoryPoint[]>([]);
    const [isLoading, setIsLoading] = useState(false);
    const [totalValueTry, setTotalValueTry] = useState(0);
    const [totalValueUsd, setTotalValueUsd] = useState(0);
    const [currentUsdRate, setCurrentUsdRate] = useState(0);
    const [cashItems, setCashItems] = useState<CashItem[]>([]);

    // Calculate total cash balance from cash items
    const cashBalance = cashItems.reduce((sum, item) => {
        if (item.currency === 'TRY') {
            return sum + item.amount;
        } else {
            return sum + (item.amount * (currentUsdRate || 1));
        }
    }, 0);

    // Load portfolio and trades from storage on mount
    useEffect(() => {
        loadData();
        fetchCurrentUsdRate();
    }, []);

    const fetchCurrentUsdRate = async () => {
        // Fetch current USD/TRY rate
        try {
            const rateData = await MarketDataService.getYahooPrice('TRY=X');
            if (rateData && rateData.currentPrice) {
                setCurrentUsdRate(rateData.currentPrice);
            }
        } catch (e) {
            console.error('Failed to fetch USD rate', e);
        }
    };

    const loadData = async () => {
        try {
            const storedPortfolio = await AsyncStorage.getItem('portfolio');
            const storedTrades = await AsyncStorage.getItem('realizedTrades');
            const storedHistory = await AsyncStorage.getItem('history');
            const storedCashItems = await AsyncStorage.getItem('cashItems');
            const storedCash = await AsyncStorage.getItem('cashBalance'); // Legacy

            if (storedPortfolio) setPortfolio(JSON.parse(storedPortfolio));
            if (storedTrades) setRealizedTrades(JSON.parse(storedTrades));
            if (storedHistory) setHistory(JSON.parse(storedHistory));

            if (storedCashItems) {
                setCashItems(JSON.parse(storedCashItems));
            } else if (storedCash) {
                // Migrate old cash balance to new structure
                const oldBalance = parseFloat(storedCash);
                if (oldBalance > 0) {
                    const defaultCashItem: CashItem = {
                        id: Date.now().toString(),
                        type: 'cash',
                        name: 'Nakit (TL)',
                        amount: oldBalance,
                        currency: 'TRY',
                        dateAdded: Date.now()
                    };
                    setCashItems([defaultCashItem]);
                    await AsyncStorage.setItem('cashItems', JSON.stringify([defaultCashItem]));
                    await AsyncStorage.removeItem('cashBalance'); // Remove old format
                }
            }
        } catch (error) {
            console.error('Failed to load data', error);
        }
    };

    const saveData = async (newPortfolio: PortfolioItem[], newTrades: RealizedTrade[], newHistory?: HistoryPoint[], newCashItems?: CashItem[]) => {
        try {
            await AsyncStorage.setItem('portfolio', JSON.stringify(newPortfolio));
            await AsyncStorage.setItem('realizedTrades', JSON.stringify(newTrades));
            setPortfolio(newPortfolio);
            setRealizedTrades(newTrades);

            if (newHistory) {
                await AsyncStorage.setItem('history', JSON.stringify(newHistory));
                setHistory(newHistory);
            }

            if (newCashItems) {
                await AsyncStorage.setItem('cashItems', JSON.stringify(newCashItems));
                setCashItems(newCashItems);
            }
        } catch (error) {
            console.error('Failed to save data', error);
        }
    };

};

// Cash Management Functions
const addCashItem = async (item: Omit<CashItem, 'id'>) => {
    const newItem: CashItem = {
        ...item,
        id: Date.now().toString(),
        dateAdded: Date.now()
    };
    const newCashItems = [...cashItems, newItem];
    await saveData(portfolio, realizedTrades, history, newCashItems);
};

const updateCashItem = async (id: string, amount: number) => {
    const newCashItems = cashItems.map(item =>
        item.id === id ? { ...item, amount } : item
    );
    await saveData(portfolio, realizedTrades, history, newCashItems);
};

const deleteCashItem = async (id: string) => {
    const newCashItems = cashItems.filter(item => item.id !== id);
    await saveData(portfolio, realizedTrades, history, newCashItems);
};

// Legacy function - adds to default TRY cash or creates one
const updateCash = async (amount: number) => {
    let defaultCash = cashItems.find(item => item.type === 'cash' && item.currency === 'TRY');

    if (defaultCash) {
        await updateCashItem(defaultCash.id, defaultCash.amount + amount);
    } else {
        await addCashItem({
            type: 'cash',
            name: 'Nakit (TL)',
            amount: amount,
            currency: 'TRY'
        });
    }
};


const updateTotalValue = async (valTry: number, valUsd: number) => {
    setTotalValueTry(valTry);
    setTotalValueUsd(valUsd);

    const today = new Date().toISOString().split('T')[0];
    let newHistory = [...history];

    // 1. Backfill History if Empty (Attempt to respect purchase dates)
    if (newHistory.length === 0 && portfolio.length > 0) {
        // Find earliest date
        const earliestItem = portfolio.reduce((prev, curr) => prev.dateAdded < curr.dateAdded ? prev : curr);
        const startDate = new Date(earliestItem.dateAdded);
        const startStr = startDate.toISOString().split('T')[0];

        if (startStr !== today) {
            // Add a starting point. 
            // We don't know the historical value, so we use the *cost basis* as a proxy for the start value.
            // This isn't perfect but better than nothing.
            let totalCostTry = 0;
            portfolio.forEach(p => {
                if (p.currency === 'USD') totalCostTry += p.amount * p.averageCost * (currentUsdRate || 30); // Fallback rate
                else totalCostTry += p.amount * p.averageCost;
            });

            newHistory.push({ date: startStr, valueTry: totalCostTry, valueUsd: totalCostTry / (currentUsdRate || 30) });
        }
    }

    // 2. Update Today's Point
    const lastPoint = newHistory[newHistory.length - 1];

    if (!lastPoint || lastPoint.date !== today) {
        // New day, add point
        newHistory.push({ date: today, valueTry: valTry, valueUsd: valUsd });
    } else {
        // Update existing today point
        if (Math.abs(lastPoint.valueTry - valTry) > 1) {
            newHistory[newHistory.length - 1] = { date: today, valueTry: valTry, valueUsd: valUsd };
        }
    }

    // 3. Sort and Limit
    newHistory.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
    // Keep last 365 days (increased from 30 to support 1Y view)
    if (newHistory.length > 365) newHistory = newHistory.slice(-365);

    if (JSON.stringify(newHistory) !== JSON.stringify(history)) {
        try {
            await AsyncStorage.setItem('history', JSON.stringify(newHistory));
            setHistory(newHistory);
        } catch (e) {
            console.error('Failed to save history', e);
        }
    }
};

const updateAsset = async (id: string, newAmount: number, newAverageCost: number) => {
    try {
        const updatedPortfolio = portfolio.map(item => {
            if (item.id === id) {
                return { ...item, amount: newAmount, averageCost: newAverageCost };
            }
            return item;
        });
        setPortfolio(updatedPortfolio);
        await AsyncStorage.setItem('portfolio', JSON.stringify(updatedPortfolio));
    } catch (error) {
        console.error('Error updating asset:', error);
    }
};

const deleteAsset = async (id: string) => {
    const updatedPortfolio = portfolio.filter(item => item.id !== id);
    await saveData(updatedPortfolio, realizedTrades, history, cashBalance);
};

const addAsset = async (asset: Omit<PortfolioItem, 'id'>) => {
    const newItem = { ...asset, id: Date.now().toString() };
    const newPortfolio = [...portfolio, newItem];
    await saveData(newPortfolio, realizedTrades, history, cashBalance);
};

const addToPortfolio = async (instrument: Instrument, amount: number, cost: number, currency: 'USD' | 'TRY', date: number, historicalUsdRate?: number, besData?: { principal: number, stateContrib: number, stateContribYield: number, principalYield: number }) => {
    let originalCostUsd = 0;
    let originalCostTry = 0;
    let rateToUse = historicalUsdRate || currentUsdRate || 30; // Fallback to 30 if no rate available

    // Calculate costs in both currencies
    if (currency === 'USD') {
        originalCostUsd = cost * amount;
        originalCostTry = cost * amount * rateToUse;
    } else { // currency === 'TRY'
        originalCostTry = cost * amount;
        originalCostUsd = cost * amount / rateToUse;
    }

    const newItem: PortfolioItem = {
        id: Date.now().toString(),
        instrumentId: instrument.symbol,
        amount,
        averageCost: cost,
        currency,
        originalCostUsd,
        originalCostTry,
        dateAdded: date,
        type: instrument.type,
        besPrincipal: besData?.principal,
        besStateContrib: besData?.stateContrib,
        besStateContribYield: besData?.stateContribYield,
        besPrincipalYield: besData?.principalYield,
    };

    // Let's find if we have this instrument.
    const existingIndex = portfolio.findIndex(p => p.instrumentId === instrument.id);
    if (existingIndex >= 0) {
        const existing = portfolio[existingIndex];
        // Weighted average for cost
        // We need to normalize to one currency for average cost calculation if they are mixed?
        // Complexity: User adds AAPL in USD, then later in TRY?
        // Let's assume we convert everything to the "main" currency of the instrument or keep the user's preference?
        // For simplicity, let's convert the new addition to the EXISTING item's currency preference.

        let newAmountToAdd = amount;
        let newCostToAdd = cost;

        if (existing.currency !== currency) {
            // Convert new addition to existing currency
            if (existing.currency === 'USD') {
                newCostToAdd = originalCostUsd;
            } else {
                newCostToAdd = originalCostTry;
            }
        }

        const totalAmount = existing.amount + newAmountToAdd;
        const totalCost = (existing.amount * existing.averageCost) + (newAmountToAdd * newCostToAdd);
        const newAvgCost = totalCost / totalAmount;

        const updatedItem = {
            ...existing,
            amount: totalAmount,
            averageCost: newAvgCost,
            originalCostUsd: (existing.originalCostUsd || 0) + (originalCostUsd * amount), // Approximate total cost tracking
            originalCostTry: (existing.originalCostTry || 0) + (originalCostTry * amount),
        };

        const updatedPortfolio = [...portfolio];
        updatedPortfolio[existingIndex] = updatedItem;
        await saveData(updatedPortfolio, realizedTrades, history, cashBalance);
    } else {
        await saveData([...portfolio, newItem], realizedTrades, history, cashBalance);
    }
};

const sellAsset = async (id: string, amountToSell: number, sellPrice: number) => {
    const itemIndex = portfolio.findIndex(p => p.id === id);
    if (itemIndex === -1) return;

    const item = portfolio[itemIndex];
    if (item.amount < amountToSell) {
        // Error: cannot sell more than owned
        return;
    }

    // Calculate Profit
    // Profit in item's currency
    const costBasis = item.averageCost * amountToSell;
    const saleProceeds = sellPrice * amountToSell;
    const profit = saleProceeds - costBasis;

    // Convert profit to USD and TRY
    let profitUsd = 0;
    let profitTry = 0;
    let proceedsTry = 0;

    if (item.currency === 'USD') {
        profitUsd = profit;
        profitTry = profit * currentUsdRate;
        proceedsTry = saleProceeds * currentUsdRate;
    } else {
        profitTry = profit;
        profitUsd = profit / (currentUsdRate || 1);
        proceedsTry = saleProceeds;
    }

    const trade: RealizedTrade = {
        id: Math.random().toString(36).substr(2, 9),
        instrumentId: item.instrumentId,
        amount: amountToSell,
        sellPrice,
        buyPrice: item.averageCost,
        currency: item.currency,
        date: Date.now(),
        profit,
        profitUsd,
        profitTry
    };

    let newPortfolio = [...portfolio];
    if (item.amount === amountToSell) {
        // Remove item
        newPortfolio.splice(itemIndex, 1);
    } else {
        // Update amount
        newPortfolio[itemIndex] = {
            ...item,
            amount: item.amount - amountToSell
        };
    }

    // Add proceeds to Cash (Yedek AkÃ§e)
    const newCash = cashBalance + proceedsTry;

    await saveData(newPortfolio, [...realizedTrades, trade], history, newCash);
};

const removeFromPortfolio = async (id: string) => {
    const updatedPortfolio = portfolio.filter(item => item.id !== id);
    await saveData(updatedPortfolio, realizedTrades, history, cashBalance);
};

const refreshPrices = async () => {
    setIsLoading(true);
    await fetchCurrentUsdRate();
    // In a real app, we would fetch updated prices for all instruments
    setIsLoading(false);
};



const totalRealizedProfitTry = realizedTrades.reduce((sum, t) => sum + t.profitTry, 0);
const totalRealizedProfitUsd = realizedTrades.reduce((sum, t) => sum + t.profitUsd, 0);

const resetData = async () => {
    try {
        await AsyncStorage.multiRemove(['portfolio', 'realizedTrades', 'history', 'cashBalance']);
        setPortfolio([]);
        setRealizedTrades([]);
        setHistory([]);
        setCashBalance(0);
    } catch (error) {
        console.error('Error resetting data:', error);
    }
};

const clearHistory = async () => {
    try {
        await AsyncStorage.removeItem('history');
        setHistory([]);
    } catch (error) {
        console.error('Error clearing history:', error);
    }
};

return (
    <PortfolioContext.Provider value={{
        portfolio,
        realizedTrades,
        history,
        cashBalance,
        addToPortfolio,
        addAsset,
        updateAsset,
        sellAsset,
        deleteAsset,
        removeFromPortfolio,
        refreshPrices,
        totalValueTry,
        totalValueUsd,
        totalRealizedProfitTry,
        totalRealizedProfitUsd,
        isLoading,
        updateTotalValue,
        updateCash,
        resetData,
        clearHistory
    }}>
        {children}
    </PortfolioContext.Provider>
);
};

export const usePortfolio = () => {
    const context = useContext(PortfolioContext);
    if (!context) {
        throw new Error('usePortfolio must be used within a PortfolioProvider');
    }
    return context;
};
